---
title: Scripts e Manipula√ß√£o de Eventos
description: >-
  Como adicionar interatividade do lado do cliente em componentes Astro
  utilizando APIs do JavaScript nativas de navegador.
i18nReady: true
---

Voc√™ pode adicionar interatividade em seus componentes Astro sem [utilizar um framework de UI](/pt-br/core-concepts/framework-components/) como React, Svelte, Vue, etc. usando tags `<script>` padr√µes do HTML. Isso te permite enviar JavaScript a ser executado no navegador e adicionar funcionalidade aos seus componentes Astro.

## Scripts no lado do Cliente

Scripts podem ser utilizados para adicionar event listeners, enviar dados de anal√≠tica, iniciar anima√ß√µes e tudo mais que o JavaScript pode fazer na web.

```astro
<!-- src/components/BotaoConfete.astro -->
<button data-botao-confete>Celebre!</button>
<script>
  // Importa m√≥dulos do npm.
  import confetti from 'canvas-confetti';
  // Encontra o DOM do componente na p√°gina.
  const botoes = document.querySelectorAll('[data-botao-confete]');
  // Adiciona event listeners para lan√ßar confete quando um bot√£o √© clicado.
  botoes.forEach((botao) => {
    botao.addEventListener('click', () => confetti());
  });
</script>
```

Por padr√£o, Astro processar√° e faz o bundle de tags `<script>`, adicionando suporte para a importa√ß√£o de m√≥dulos do npm, uso de TypeScript e mais.

## Utilizando `<script>` no Astro

Em arquivos `.astro`, voc√™ pode adicionar JavaScript no lado do cliente adicionando uma (ou mais) tags `<script>`.

Neste exemplo, adicionar o componente `<Ola />` a uma p√°gina ir√° registrar uma mensagem no console do navegador.

```astro title="src/components/Ola.astro"
<h1>Ol√°, mundo!</h1>

<script>
  console.log('Ol√°, console do navegador!');
</script>
```

### Processamento do Script

Por padr√£o, tags `<script>` s√£o processadas pelo Astro.

- Quaisquer importa√ß√µes passaram por bundle, te permitindo importar arquivos locais ou m√≥dulos do Node.
- O script processado ser√° injetado no `<head>` da sua p√°gina com [`type="module"`](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Modules).
- TypeScript √© completamente suportado, incluindo a importa√ß√£o de arquivos TypeScript.
- Se o seu componente √© usado v√°rias vezes em uma p√°gina, o script ser√° adicionado apenas uma vez.

```astro title="src/components/Exemplo.astro"
<script>
  // Processado! Passou por bundle! TypeScript suportado!
  // Importar scripts locais e m√≥dulos do Node funciona.
</script>
```

O atributo `type="module"` faz com que o navegador trate o script como um m√≥dulo JavaScript. Isso traz v√°rios benef√≠cios de desempenho:
- A renderiza√ß√£o n√£o √© bloqueada. O navegador continua a processar o restante do HTML enquanto o script do m√≥dulo e suas depend√™ncias s√£o carregados.
- O navegador aguarda o processamento do HTML antes de executar scripts de m√≥dulo. Voc√™ n√£o precisa escutar o evento "load".
- Os atributos `async` e `defer` s√£o desnecess√°rios. Os scripts de m√≥dulo s√£o sempre adiados.

:::note
O atributo `async` √© valioso para scripts normais, pois impede que eles bloqueiem a renderiza√ß√£o. No entanto, os scripts de m√≥dulo j√° possuem esse comportamento. Adicionar `async` a um script de m√≥dulo far√° com que ele seja executado antes que a p√°gina tenha carregado completamente. Isso provavelmente n√£o √© o que voc√™ deseja.
:::

### Optando por n√£o processar
Para evitar fazer o bundle do script, voc√™ pode adicionar a diretiva `is:inline`.

```astro title="src/components/ScriptInline.astro" "is:inline"
<script is:inline>
  // Ser√° renderizado no HTML assim como escrito!
  // Importa√ß√µes locais n√£o s√£o resolvidas e n√£o ir√£o funcionar.
  // Se estiver em um componente, √© repetido cada vez que o componente √© utilizado.
</script>
```

:::note
Astro n√£o processara suas tags de script em algumas situa√ß√µes. Especialmente, ao adicionar `type="module"` ou qualquer outro atributo diferente de `src` a uma tag `<script>` ir√° fazer com que o Astro trate a tag como se ela tivesse a diretiva `is:inline`. O mesmo ser√° verdade quando o script √© escrito em uma express√£o JSX.
:::

üìö Veja nossa p√°gina de [refer√™ncia de diretivas](/pt-br/reference/directives-reference/#diretivas-de-script-e-estiliza√ß√£o) para mais informa√ß√µes sobre as diretivas dispon√≠veis em tags `<script>`.

### Incluindo arquivos javascript na sua p√°gina

Voc√™ pode desejar escrever seus scripts como arquivos `.js`/`.ts` separados ou precisa referenciar um script externo em outro servidor. Voc√™ pode fazer isso os referenciando no atributo `src` de uma tag `<script>`.

#### Importando scripts locais

**Quando utilizar isto:** Se o seu script est√° dentro de `src/`.

Astro ir√° fazer a build, otimizar e adicionar esses scripts a p√°gina para voc√™, seguindo suas [regras de processamento de script](#processamento-do-script).

```astro title="src/components/ScriptsLocais.astro"
<!-- caminho relativo ao script em `src/scripts/local.js` -->
<script src="../scripts/local.js"></script>

<!-- tamb√©m funciona para arquivos TypeScript locais -->
<script src="./script-com-tipos.ts"></script>
```

#### Carregando scripts externos

**Quando utilizar isto:** Se o seu arquivo JavaScript est√° dentro de `public/` ou em uma CDN.

Para carregar scripts fora do diret√≥rio `src/` do seu projeto, inclua a diretiva `is:inline`. Esta abordagem pula o processamento, bundling e otimiza√ß√µes do JavaScript que s√£o providenciadas pelo Astro quando voc√™ importa scripts como descrito acima.

```astro title="src/components/ScriptsExternos.astro" "is:inline"
<!-- caminho absoluto ao script em `public/meu-script.js` -->
<script is:inline src="/meu-script.js"></script>

<!-- URL completa para um script em um servidor remoto -->
<script is:inline src="https://minhas-analytics.com/script.js"></script>
```

## Padr√µes de script comuns

### Manipulando `onclick` e outros eventos

Alguns frameworks de UI utilizam uma sintaxe customizada para manipular eventos como `onClick={...}` (React/Preact) ou `@click="..."` (Vue). Astro segue mais fielmente o HTML padr√£o e n√£o utiliza uma sintaxe customizada para eventos.

No lugar, voc√™ pode utilizar [`addEventListener`](https://developer.mozilla.org/pt-BR/docs/Web/API/EventTarget/addEventListener) em uma tag `<script>` para manipular a intera√ß√£o do usu√°rio.

```astro title="src/components/BotaoAlerta.astro"
<button class="alerta">Me clique!</button>

<script>
  // Encontre todos os bot√µes com a classe `alerta` na p√°gina.
  const botoes = document.querySelectorAll('button.alerta');

  // Manipule cliques em cada um dos bot√µes.
  botoes.forEach((botao) => {
    botao.addEventListener('click', () => {
      alert('Bot√£o foi clicado!');
    });
  });
</script>
```

:::note
Se voc√™ tem m√∫ltiplos componentes `<BotaoAlerta />` em uma p√°gina, Astro n√£o ir√° executar o script m√∫ltiplas vezes. Scripts passam por bundle e s√£o inclusos apenas uma vez por p√°gina. Utilizar `querySelectorAll` garante que este script anexe o event listener para cada bot√£o com a classe `alerta` encontrado na p√°gina.
:::

### Web components com elementos customizados

Voc√™ pode criar seus pr√≥prios elementos HTML com comportamentos customizados usando o padr√£o Web Components. Definir um [elemento customizado](https://developer.mozilla.org/pt-BR/docs/Web/Web_Components/Using_custom_elements) em um componente `.astro` te permite construir componentes interativos sem precisar de uma biblioteca ou framework de UI.

Neste exemplo, definimos um novo elemento HTML `<coracao-astro>` que rastreia quantas vezes voc√™ clicou no bot√£o de cora√ß√£o e atualiza a `<span>` com o contagem atual.

```astro title="src/components/CoracaoAstro.astro"
<!-- Envolve os elementos do componente em nosso elemento customizado ‚Äúcoracao-astro‚Äù. -->
<coracao-astro>
  <button aria-label="Cora√ß√£o">üíú</button> √ó <span>0</span>
</coracao-astro>

<script>
  // Define o comportamento para nosso novo tipo de elemento HTML.
  class CoracaoAstro extends HTMLElement {
    constructor() {
			super();
      let contagem = 0;

      const botaoCoracao = this.querySelector('button');
      const spanContagem = this.querySelector('span');

      // Cada vez que o bot√£o √© clicado atualiza a contagem.
			botaoCoracao.addEventListener('click', () => {
        contagem++;
        spanContagem.textContent = contagem.toString();
      });
		}
  }

  // Diz ao navegador para usar a nossa classe CoracaoAstro para elementos <coracao-astro>.
  customElements.define('coracao-astro', CoracaoAstro);
</script>
```

H√° duas vantagens em utilizar um elemento customizado aqui:

1. Ao inv√©s de procurar em toda a p√°gina usando `document.querySelector()`, voc√™ pode utilizar `this.querySelector()`, que apenas pesquisa dentro da inst√¢ncia do elemento customizado atual. Isso torna mais f√°cil trabalhar apenas com filhos de uma inst√¢ncia de componente por vez.

2. Apesar do `<script>` ser executado apenas uma vez, o navegador ir√° executar o m√©todo `constructor()` cada vez que ele encontrar um `<coracao-astro>` na p√°gina. Isso significa que voc√™ pode de forma segura escrever c√≥digo para um componente por vez, mesmo que voc√™ planeje utilizar o componente m√∫ltiplas vezes em uma p√°gina.

üìö Voc~e pode aprender mais sobre elementos customizados no [guia "Reusable Web Components" do web.dev](https://web.dev/custom-elements-v1/) e na [introdu√ß√£o da MDN a elementos customizados](https://developer.mozilla.org/pt-BR/docs/Web/Web_Components/Using_custom_elements).

### Passando vari√°veis frontmatter a scripts

Em componentes Astro, o c√≥digo [no frontmatter](/pt-br/core-concepts/astro-components/#o-script-do-componente) entre as cercas `---` √© executado no servidor e n√£o est√° dispon√≠vel no navegador. Para enviar vari√°veis do servidor para o cliente, n√≥s precisamos de uma forma de armazenar nossas vari√°veis e ent√£o as ler quando o JavaScript √© executado no navegador.

Uma forma de fazer isso √© utilizando [atributos `data-*`](https://developer.mozilla.org/pt-BR/docs/Learn/HTML/Howto/Use_data_attributes) para armazenar o valor das vari√°veis no HTML resultante. Scripts, incluindo elementos customizados, podem ler esses atributos utilizando a propriedade `dataset` de um elemento assim que o HTML √© carregado no navegador.

Neste componente de exemplo, uma prop `mensagem` √© armazenada no atributo `data-mensagem` para que o elemento customizado possa ler `this.dataset.mensagem` e obter o valor da prop no navegador.

```astro title="src/components/SaudacaoAstro.astro" {2} /data-mensagem={.+}/ "this.dataset.mensagem"
---
const { mensagem = 'Ol√°, mundo!' } = Astro.props;
---

<!-- Armazena a prop mensagem como um atributo `data-*`. -->
<saudacao-astro data-mensagem={mensagem}>
  <button>Diga ol√°!</button>
</saudacao-astro>

<script>
  class SaudacaoAstro extends HTMLElement {
    constructor() {
			super();

      // Leia a mensagem do atributo `data-*`.
      const mensagem = this.dataset.mensagem;
      const botao = this.querySelector('button');
      botao.addEventListener('click', () => {
        alert(mensagem);
      });
		}
  }

  customElements.define('saudacao-astro', SaudacaoAstro);
</script>
```

Agora podemos utilizar nosso componente m√∫ltiplas vezes e seremos cumprimentados com uma mensagem diferente para cada uma.

```astro title="src/pages/exemplo.astro"
---
import SaudacaoAstro from '../components/SaudacaoAstro.astro';
---

<!-- Utiliza a mensagem padr√£o: ‚ÄúOl√°, mundo!‚Äù -->
<SaudacaoAstro />

<!-- Utiliza mensagens customizadas passadas como props. -->
<SaudacaoAstro mensagem="Um belo dia para construir componentes!" />
<SaudacaoAstro mensagem="Que bom que voc√™ chegou! üëã" />
```

:::tip[Voc√™ sabia?]
Isto √© o que o Astro faz nos bastidores quando voc√™ passa props para um componente escrito utilizando um framework de UI como React! Para componentes com uma diretiva `client:*`, o Astro cria um elemento customizado `<astro-island>` com o atributo `props` que armazena as suas props do lado do servidor no HTML resultante.
:::
