---
title: Referencia de directivas de maquetado
i18nReady: true
---

**Las directivas de maquetado** son atributos especiales de HTML disponibles dentro del maquetado de los componentes de Astro (archivos `.astro`), algunas de ellas tambi칠n pueden usarse en archivos `.mdx`.

Las directivas de maquetado se utilizan para controlar el comportamiento de un elemento o componente de cierta forma. Una directiva de maquetado puede habilitar alguna caracter칤stica del compilador que te haga la vida m치s f치cil (como usar `class:list` en lugar de `class`). O bien, una directiva puede decirle al compilador de Astro que haga algo especial con ese componente (como hidratar con `client:load`).

Esta p치gina describe todas las directivas de maquetado disponibles en Astro y c칩mo funcionan.

## Reglas

Para que una directiva de maquetado sea v치lida, debes:

- Incluir dos puntos `:` en su nombre, usando la forma `X:Y` (ej.: `client:load`).
- Ser visible para el compilador (ej.: `<X {...attr}>` no funcionar칤a si `attr` contuviera una directiva).

Algunas directivas de plantilla, no todas, pueden tomar un valor personalizado:
- `<X client:load />` (no toma valor)
- `<X class:list={['some-css-class']} />` (toma una matriz)

Una directiva de maquetado nunca se incluye directamente en el HTML del compilado final de un componente.

## Directivas comunes

### `class:list`

`class:list={...}` toma un array de clases y los convierte en un string. Esto est치 impulsado por la popular biblioteca auxiliar de [@lukeed](https://github.com/lukeed/clsx) llamada [clsx](https://github.com/lukeed/clsx).

`class:list` toma un array de varios tipos de valores posibles diferentes:
- `string`: Agregado al elemento `class`
- `Object`: Todas las keys verdaderas se agregan al elemento `class`
- `Array`: aplanado
- `false`, `null`, o `undefined`: Omitido

```astro
<!-- Esto -->
<span class:list={[ 'hello goodbye', { world: true }, [ 'friend' ] ]} />
<!-- Se convierte en -->
<span class="hello goodbye world friend"></span>
```

### `set:html`

`set:html={string}` inyecta un string de HTML en un elemento, similar a la opci칩n `el.innerHTML`.

**춰Astro no verifica autom치ticamente el valor!** Aseg칰rate que conf칤as en el valor o verificalo manualmente antes de pasarlo al maquetado. Olvidar hacer esto te expondr치 a ataques de [Cross Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/).

```astro
---
const rawHTMLString = "Hola <strong>Mundo</strong>"
---
<h1>{rawHTMLString}</h1>
  <!-- Resultado: <h1>Hola &lt;strong&gt;Mundo&lt;/strong&gt;</h1> -->
<h1 set:html={rawHTMLString} />
  <!-- Resultado: <h1>Hola <strong>Mundo</strong></h1> -->
```

Tambi칠n puedes usar `set:html` en un `<Fragment>` para evitar agregar un elemento contenedor innecesario. Esto puede ser especialmente 칰til al obtener HTML de un CMS.

```astro
---
const cmsContent = await fetchHTMLFromMyCMS();
---
<Fragment set:html={cmsContent}>
```

### `set:text`

`set:text={string}` inyecta un string de texto en un elemento, similar a `el.innerText`. A diferencia de `set:html`, Astro verifica autom치ticamente al valor `string` que se pasa.

Esto equivale a pasar una variable a una expresi칩n de maquetado de forma directa (por ejemplo: `<div>{someText}</div>`) y, por lo tanto, esta directiva no se usa com칰nmente.

## Directivas del cliente

Estas directivas controlan c칩mo se hidratan los [componentes de framework](/es/core-concepts/framework-components/) en la p치gina.

De forma predeterminada, un componente de framework no est치 hidratado en el cliente. Si no se proporciona la directiva `client:*`, su HTML se representa en la p치gina sin JavaScript.

Una directiva de cliente puede ser usada solamente en un componente de framework UI que sea directamente importado en un componente `.astro`. Las directivas de hidrataci칩n no son compatibles cuando se usan [etiquetas din치micas](/es/core-concepts/astro-syntax/#etiquetas-din치micas) y [componentes personalizados pasados a trav칠s de la propiedad `components`](/es/guides/markdown-content/#componentes-personalizados-con-mdx-importado).

### `client:load`

- **Prioridad:** Alta
- **칔til para:** Elementos de la UI inmediatamente visibles que deben ser interactivos lo antes posible.

Carga e hidrata el JavaScript del componente inmediatamente al cargar la p치gina.

```astro
<BuyButton client:load />
```

### `client:idle`

- **Prioridad:** Media
- **칔til para:** Elementos de UI de menor prioridad que no necesitan ser interactivos inmediatamente.

Carga e hidrata el componente JavaScript una vez que la p치gina haya terminado con su carga inicial y se haya activado el evento `requestIdleCallback`. Si est치 en un navegador que no es compatible con [`requestIdleCallback`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), entonces se usar치 el evento [`load`](https://developer.mozilla.org/es/docs/Web/API/Window/load_event).

```astro
<ShowHideButton client:idle />
```

### `client:visible`

- **Prioridad:** Baja
- **칔til para:** Elementos de la interfaz de usuario de baja prioridad que se encuentran en la parte inferior de la p치gina ("que no son visibles al usuario") o que requieren tantos recursos para cargar que preferir칤a no cargarlos en absoluto si el usuario nunca vio el elemento.

Carga e hidrata el JavaScript del componente una vez que haya ingresado al viewport del usuario. Esto utiliza un `IntersectionObserver` internamente para realizar un seguimiento de la visibilidad.

```astro
<HeavyImageCarousel client:visible />
```

### `client:media`

- **Prioridad:** Baja
- **칔til para:** Alternar las barras de navegaci칩n u otros elementos que solo deben mostrarse en ciertos tama침os de pantalla.

`client:media={string}` carga e hidrata el componente JavaScript una vez que se cumple una determinada media query de CSS.

:::note
Si el componente ya est치 oculto y se muestra mediante media queries de CSS, entonces puede ser m치s f치cil simplemente usar `client:visible` y no pasar la misma media query a la directiva.
:::

```astro
<SidebarToggle client:media="(max-width: 50em)" />
```

### `client:only`

`client:only={string}` **evita** la renderizaci칩n del servidor HTML y solo se renderiza en el cliente. Act칰a de manera similar a `client:load` en el sentido de que carga, procesa e hidrata el componente inmediatamente al cargar la p치gina.

**춰Debes pasar el framework correcto al componente!** Debido a que Astro no ejecuta el componente durante su compilaci칩n/en el servidor, Astro no sabe qu칠 framework usa el componente a menos que se lo indiques expl칤citamente.

```astro
<SomeReactComponent client:only="react" />
<SomePreactComponent client:only="preact" />
<SomeSvelteComponent client:only="svelte" />
<SomeVueComponent client:only="vue" />
<SomeSolidComponent client:only="solid-js" />
```

### Directivas de cliente personalizadas

Desde Astro 2.6.0, las integraciones tambi칠n pueden agregar directivas `client:*` personalizadas para cambiar c칩mo y cu치ndo se deben hidratar los componentes.

Consulta la [API `addClientDirective`](/es/reference/integrations-reference/#opci칩n-addclientdirective) para saber m치s sobre c칩mo crear una directiva de cliente personalizada.


## Directivas Script & Style

Estas directivas solo se pueden usar en etiquetas HTML `<script>` y `<style>`, para controlar c칩mo se manejan el JavaScript y CSS del lado del cliente en la p치gina.

### `is:global`

De forma predeterminada, Astro aplica autom치ticamente las reglas CSS `<style>` localmente al componente. Puedes optar por no participar con este comportamiento con la directiva `is:global`.

`is:global` hace que el contenido de una etiqueta `<style>` se aplique globalmente en la p치gina cuando el componente es incluido. Esto deshabilita el alcance local de CSS de Astro. Esto es equivalente a envolver todos los selectores dentro de una etiqueta `<style>` con `:global()`.

Puedes combinar `<style>` y `<style is:global>` juntos en el mismo componente para crear algunas reglas de estilo globales mientras mantienes la mayor parte del CSS con un alcance local dentro del componente de Astro.

游닄 Consulta la p치gina [Estilos & CSS](/es/guides/styling/#estilos-globales) para obtener m치s detalles sobre c칩mo funcionan los estilos globales.

```astro
<style is:global>
  body a { color: red; }
</style>
```

### `is:inline`

De forma predeterminada, Astro procesar치, optimizar치 y empaquetar치 cualquier etiqueta `<script>` y `<style>` que vea en la p치gina. Puedes optar por evitar este comportamiento con la directiva `is:inline`.

`is:inline` le indica a Astro que deje la etiqueta `<script>` o `<style>` tal como est치 en el HTML final. Los contenidos no ser치n procesados, optimizados o agrupados. Esto limita algunas caracter칤sticas de Astro, como importar un paquete npm o usar un lenguaje de compilaci칩n a CSS como Sass.

La directiva `is:inline` significa que las etiquetas `<style>` y `<script>`:

- No se empaquetar치n como un archivo externo. Esto significa que [atributos tales como `defer`](https://es.javascript.info/script-async-defer) que controlan la carga de archivos externos, no tendr치n efecto.
- No se deduplicar치n: el elemento aparecer치 tantas veces como se represente.
- No se resolver치n sus referencias `import`/`@import`/`url()` en relaci칩n con el archivo `.astro`.
- Se renderizar치n en el HTML final exactamente donde se crearon.
- Los estilos ser치n globales y no tendr치n alcance local en el componente.

:::caution
La directiva `is:inline` est치 impl칤cita cada vez que se usa cualquier atributo que no sea `src` en una etiqueta `<script>` o `<style>`.
:::

```astro
<style is:inline>
  /* inline: Las importaciones de paquetes relativos y npm no son compatibles. */
  @import '/assets/some-public-styles.css';
  span { color: green; }
</style>

<script is:inline>
  /* inline: Las importaciones de paquetes relativos y npm no son compatibles. */
  console.log('Estoy inline aqu칤 en el HTML generado.');
</script>
```

游닄 Mira c칩mo funcionan los [scripts del lado del cliente](/es/guides/client-side-scripts/) en los componentes de Astro.

### `define:vars`

`define:vars={...}` pueden pasar variables del servidor desde el frontmatter del componente a las etiquetas `<script>` o `<style>` del cliente. Cualquier variable de frontmatter *JSON-serializable* es compatible, incluyendo las `props` pasadas al componente a trav칠s de `Astro.props`. Los valores son serializados por medio de [`JSON.stringify()`](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)

```astro
---
const foregroundColor = "rgb(221 243 228)";
const backgroundColor = "rgb(24 121 78)";
const message = "춰Astro es espectacular!";
---
<style define:vars={{ textColor: foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--textColor);
  }
</style>

<script define:vars={{ message }}>
  alert(message);
</script>
```

:::caution
El uso de `define:vars` en una etiqueta `<script>` o `<style>` implica la directiva [`is:inline`](#isinline), lo que significa que los scripts o estilos no se empaquetar치n y ser치n incluidos inline directamente en el HTML.

Esto se debe a que cuando Astro empaqueta los scripts, Astro incluye y ejecuta los scripts una sola vez, aun si incluyes el componente que contiene el script m칰ltiples veces en una p치gina. `define:vars` requiere que un script se re-ejecute con los valores asignados, luego Astro crea, en su lugar, un script inline.

Para scripts, intenta [pasar variables a los scripts manualmente](/es/guides/client-side-scripts/#pasando-variables-frontmatter-a-scripts) en su lugar.
:::

## Directivas avanzadas

### `is:raw`

`is:raw` indica al compilador de Astro que trate a cualquier elemento hijo de ese componente como texto. Esto significa que toda la sintaxis especial de maquetado de Astro se ignorar치 dentro de este componente.

Usado internamente por el componente `<Markdown />`.

Por ejemplo, si tuvieras un componente Katex personalizado que convierte texto a HTML, podr칤as hacer que los usuarios hicieran esto:

```astro
---
import Katex from '../components/Katex.astro';
---
<Katex is:raw>Algunas {sintaxis} conflictivas aqu칤</Katex>
```
